<!--This file created 5/4/00 9:37 PM by Claris Home Page version 1.0--><HTML><HEAD>   <TITLE>BufferedFile</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 1.0">   <X-SAS-WINDOW TOP=46 BOTTOM=763 LEFT=141 RIGHT=1004></HEAD><BODY BGCOLOR="#FFFFFF"><H1>BufferedFile</H1><P>&nbsp;</P><P>Derived from: <B>BFile</B></P><P>Declared in: <B>BufferedFile.h</B></P><P>Library: <B>none</B></P><P><HR></P><H2><A NAME="Overview"></A>Overview</H2><P>&nbsp;</P><P>BufferedFile is a class which buffers file access. Lacks the extrafeatures provided by EndianIndependentFile, but this is useful forbuffering I/O for a text file or other file formats where the extrabyte that BufferedFile sticks on the front of the file to indicateendianness interferes with the output file. BufferedFile stillprovides all of the functionality of a BFile: It now providesRead/Write access, random access, etc. All the regular BFile callscan be mixed with the BufferedFile calls, although the BFile callswon't benefit from the buffering (they force the buffer to flush, andactually introduce inefficiency - use them carefully; in general tryto stick to the BufferedRead and BufferedWrite calls). A word ofwarning regarding the use of SetTo: these methods are NOT VIRTUAL inBFile, so if you access them on a BufferedFile, make sure that youare accessing it as a BufferedFile, and not cast to the parent BFileclass.</P><P>&nbsp;</P><P>&nbsp;<HR></P><H2><A NAME="Constructor and Destructor"></A>Constructor andDestructor</H2><P><HR></P><H3><A NAME="BufferedFile()"></A>BufferedFile()</H3><PRE>      BufferedFile(const entry_ref* ref, uint32 openMode, int32 BufferSize = 4095)      BufferedFile(const BEntry* entry, uint32 openMode, int32 BufferSize = 4095)      BufferedFile(const char* path, uint32 openMode, int32 BufferSize = 4095)      BufferedFile(BDirectory* dir, const char* path, uint32 openMode, int32 BufferSize = 4095)</PRE><P>Creates a new BufferedFile object, initializes it according to thearguments, and sets<B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> to return thestatus of the initialization.</P><P><B>See also:<TT><A HREF="/boot/beos/documentation/Be%20Book/The%Storage%20Kit/File.html#BFile()">BFile::BFile()</A></TT></B></P><P><HR></P><H3><A NAME="~BetterScrollView()"></A>~BufferedFile()</H3><PRE>      virtual <TT>~</TT>BufferedFile<TT>()</TT> </PRE><P>Closes the object's file, frees its file descriptor, and destroysthe object. Destroys the BufferedFile, but DOES NOT write anybuffered data, as a file error could occur without the opportunity toreport the error. You must call FlushBuffer() before destroying theBufferedFile in order to write any data in the write buffer.</P><P><B>See also:<TT><A HREF="/boot/beos/documentation/Be%20Book/The%Storage%20Kit/File.html#~BFile()">BFile::~BFile()</A></TT></B></P><P><HR></P><H2><A NAME="Member Functions"></A>Member Functions</H2><P>&nbsp;</P><P><HR></P><H3><A NAME="BufferedPreview()"></A>BufferedPreview(),<A NAME="BufferedRead()"></A>BufferedRead(),<A NAME="BufferedReadLine()"></A>BufferedReadLine(),<A NAME="BufferedWrite()"></A> BufferedWrite()</H3><PRE>      ssize_t BufferedPreview(void* PreviewBuffer, size_t BytesToPreview)      ssize_t BufferedRead(void* ReadBuffer, size_t BytesToRead)      ssize_t BufferedReadLine(void* LineBuffer, size_t LineBufferSize)      ssize_t BufferedWrite(const void* WriteBuffer, size_t BytesToWrite)</PRE><P>Reads or writes the raw data contained in ReadBuffer orWriteBuffer. Returns the number of bytes actually read or written.For BufferedPreview, BytesToPreview can't be larger than the buffersize and will not move the position from which BufferedRead will readdata. BufferedReadLine will read up to LineBufferSize bytes intoLineBuffer, and will read one line of data (up to the first carriagereturn and/or linefeed, accepting BeOS/Unix, Windows, or Macend-of-lines: LF, CR/LF, CR respectively).</P><H3><HR><A NAME="FlushBuffer()"></A>FlushBuffer()</H3><PRE>      status_t FlushBuffer()</PRE><P>Flushes the read or write buffer and moves the file pointer to theposition that was being read or written in the buffer. The buffer isautomatically flushed when necessary when working within the file,but if you have buffered write data, call it yourself before deletingthe BufferedFile to make sure the data is written successfully (thedestructor can't return an error code). Returns B_NO_ERROR if thebuffer was flushed successfully.</P><P><HR></P><H3><A NAME="InitCheck()"></A>InitCheck()</H3><PRE>      virtual status_t InitCheck()</PRE><P>Returns B_NO_ERROR if the BufferedFile was created successfully.</P><P><B>See also:<TT><A HREF="/boot/beos/documentation/Be%20Book/The%Storage%20Kit/File.html#InitCheck()">BFile::InitCheck()</A></TT></B></P><P><HR></P><P>By Brian Tietz</P><P>Copyright 2000</P><P>Bug reports (including documentation errors) and feature requestscan be sent to<A HREF="mailto:briant@timelinevista.com">briant@timelinevista.com</A>.</P><P>&nbsp;</P><P>&nbsp;</P></BODY></HTML>