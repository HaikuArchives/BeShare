<!--This file created 5/7/00 11:05 AM by Claris Home Page version 1.0--><HTML><HEAD>   <TITLE>BufferedFile</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 1.0">   <X-SAS-WINDOW TOP=46 BOTTOM=763 LEFT=141 RIGHT=1004></HEAD><BODY BGCOLOR="#FFFFFF"><H1>EndianIndependentFile</H1><P>&nbsp;</P><P>Derived from: <B>BufferedFile</B></P><P>Declared in: <B>EndianIndependentFile.h</B></P><P>Library: <B>none</B></P><P><HR></P><H2><A NAME="Overview"></A>Overview</H2><P><TT>BFile</TT>-derived class which adds a layer of abstraction andavoids having to worry about several issues:</P><P>- "endian-ness":  When you create a EndianIndependentFile for reador write, the first thing it does is read or write a single byte flagto indicate the endianness of the file, and automatically converts tonative byte order if necessary when reading as long as you use theReadNumber and WriteNumber functions.</P><P>- size of numbers:  If I'm going down a structure with lots ofmembers, writing each member, I find it annoying to have toconstantly check the type of each member, then call the appropriatesized byte swap if necessary and write the appropriate size manually. It is especially annoying when some members are not base types (forexample, time_t is not a base type - you have to know or look up tofind out that it is int64).  ReadNumber and WriteNumber accept anysize or type of data (integers, floats, etc) and treat itappropriately.  Thus, to write an array time_t TimeArray[5]:MyFile-&gt;WriteNumber(TimeArray,sizeof(time_t),5)</P><P>- strings:  How do you write a string?  The length first, followedby the string, or omit the length and search for the null terminatorwhen you read?  The former adds extra size, while the latter isinefficient without buffering of the read data. EndianIndependentFile provides ReadString() and WriteString() tohandle that for you.  No big deal but it simplifies things and keepscode more readable.</P><P>- The last advantage is that it inherits from BufferedFile andbuffers the data during read and write, so that you can convenientlyread/write the small pieces at a time (one member at a time, forexample) without costly repeated calls to the storage server.  Justusing BFile, you would need to manually fill a write buffer for thesake of efficiency and not call BFile::Read() or BFile::Write() toomany times for small data elements.  With buffering, it is just asefficient to write a byte or an int at a time.  This saves the hassleby buffering output for you, allowing you to focus on the task athand, namely writing your data one piece at a time while keeping yourcode simple and readable.  </P><P>EndianIndependentFile still provides all of the functionality of aBFile: It now provides Read/Write access, random access, etc.  Allthe regular BFile calls can be mixed with the EndianIndependentFilecalls, although the BFile calls won't benefit from the buffering(they force the buffer to flush, and actually introduce inefficiency- use them carefully; in general try to stick to theEndianIndependentFile-specific calls.</P><P>&nbsp;<HR></P><H2><A NAME="Constructor and Destructor"></A>Constructor andDestructor</H2><P><HR></P><H3><A NAME="EndianIndependentFile()"></A>EndianIndependentFile()</H3><PRE>      EndianIndependentFile(const entry_ref* ref, uint32 openMode, int32 BufferSize = 4095)      EndianIndependentFile(const BEntry* entry, uint32 openMode, int32 BufferSize = 4095)      EndianIndependentFile(const char* path, uint32 openMode, int32 BufferSize = 4095)      EndianIndependentFile(BDirectory* dir, const char* path, uint32 openMode, int32 BufferSize = 4095)</PRE><P>Creates a new virtual <TT>EndianIndependentFile</TT> object,initializes it according to the arguments, and sets<B><TT><A HREF="#InitCheck()">InitCheck()</A></TT></B> to return thestatus of the initialization.  If opening for read, sets the object'sendianness to that recorded in the first byte of the file.  Ifopening a new file for write, sets the object's endianness to that ofthe host system and writes one byte to the file to indicate theendianness.</P><P><B>See also:<TT><A HREF="BufferedFile.html#BufferedFile()">BufferedFile::BufferedFile()</A></TT></B></P><P><HR></P><H3><A NAME="~EndianIndependentFile()"></A>~EndianIndependentFile()</H3><PRE>      virtual ~EndianIndependentFile() </PRE><P>Closes the object's file, frees its file descriptor, and destroysthe object. Destroys the EndianIndependentFile, but DOES NOT writeany buffered data, as a file error could occur without theopportunity to report the error. You must call<TT><A HREF="BufferedFile.html#FlushBuffer()">FlushBuffer()</A></TT>before destroying the EndianIndependentFile in order to write anydata in the write buffer.</P><P><B>See also:<TT><A HREF="BufferedFile.html#~BufferedFile()">BufferedFile::~BufferedFile()</A></TT>,<TT><A HREF="BufferedFile.html#FlushBuffer()">BufferedFile::FlushBuffer()</A></TT></B></P><P><HR></P><H2><A NAME="Member Functions"></A>Member Functions</H2><P><HR></P><H3><A NAME="IsBigEndian()"></A>IsBigEndian(),<A NAME="IsNativeEndian()"></A>IsNativeEndian()</H3><PRE>&nbsp;      bool IsBigEndian()      bool IsNativeEndian()&nbsp;</PRE><P><TT>IsBigEndian()</TT> returns true if the file is in big endianformat.  IsNativeEndian() returns true if the file is in the nativeendianness format for the host system.</P><P><HR></P><H3><A NAME="ReadRaw()"></A>ReadRaw(),<A NAME="WriteRaw()"></A>WriteRaw(),<A NAME="ReadString()"></A>ReadString(),<A NAME="WriteString()"></A>WriteString(),<A NAME="ReadNumber()"></A>ReadNumber(),<A NAME="WriteNumber"></A> WriteNumber()</H3><PRE>&nbsp;      int32 ReadRaw(void* Buffer, size_t BytesToRead)      int32 WriteRaw(const void* Buffer, size_t BytesToWrite)      status_t ReadString(char* Buffer, int32 BufferSize)      status_t WriteString(const char* Buffer)      int32 ReadNumber(void* Buffer, uint8 SizeOfData, int32 NumbersToRead = 1)      int32 WriteNumber(void* Buffer, uint8 SizeOfData, int32 NumbersToWrite = 1)</PRE><P>&nbsp;</P><P>Reads or writes the raw data, string, or number.  The<TT>ReadNumber(</TT>) and <TT>WriteNumber()</TT> pair read or writethe number in the endianness appropriate for the file, as determinedin the <TT>EndianIndependentFile</TT> constructor.  The length of thenumber written may be 1,2,4, or 8 bytes.</P><P><HR></P><P>By Brian Tietz</P><P>Copyright 2000</P><P>Bug reports (including documentation errors) and feature requestscan be sent to<A HREF="mailto:briant@timelinevista.com">briant@timelinevista.com</A>.</P><P>&nbsp;</P><P>&nbsp;</P></BODY></HTML>