<!--This file created 5/6/00 7:24 PM by Claris Home Page version 1.0--><HTML><HEAD>   <TITLE>ChecksumDataBuffer</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 1.0">   <X-SAS-WINDOW TOP=43 BOTTOM=760 LEFT=57 RIGHT=920></HEAD><BODY BGCOLOR="#FFFFFF"><H1>ChecksumDataBuffer</H1><P>&nbsp;</P><P>Derived from: <B>none</B></P><P>Declared in: <B>ChecksumDataBuffer.h</B></P><P>Library: <B>none</B></P><P><HR></P><H2><A NAME="Overview"></A>Overview</H2><P>&nbsp;</P><P>ChecksumDataBuffer is a class which buffers data for transmissionover a network. Its intended use is to write the data to the buffer,generate a checksum for the data, write the checksum to the buffer aswell, and finally transmit the full buffer. Typically, there will bedata at the beginning of the message indicating the overall length ofthe message. To facilitate this, you can also write to a specifiedposition in the buffer. For example, you could write an int32 zerolength at the beginning of the buffer, write the buffer content, readthe buffer length once you're finished, write that length at positionzero, generate a checksum, write the checksum to the end of thebuffer, and send it.</P><P>&nbsp;<HR></P><H2><A NAME="Constructor and Destructor"></A>Constructor andDestructor</H2><P><HR></P><H3><A NAME="ChecksumDataBuffer()"></A>ChecksumDataBuffer()</H3><PRE>&nbsp;      ChecksumDataBuffer(uint32 growth_increment, bool use_network_order)</PRE><P>&nbsp;</P><P>Creates a new ChecksumDataBuffer object, and initializes itaccording to the arguments. The growth_increment specified theinitial buffer size, but if the message grows beyond this size, thebuffer will continue to grow to hold the data. Note that the bufferstores the entire message so you probably shouldn't let the messagegrow beyond a couple of megabytes at the most. If a message can getthat big, you want to transmit it directly without buffering.</P><P><HR></P><H3><A NAME="~ChecksumDataBuffer()"></A>~ChecksumDataBuffer()</H3><PRE>&nbsp;      virtual <TT>~</TT>ChecksumDataBuffer<TT>()</TT> </PRE><P>&nbsp;</P><P>Destroys the object and frees all memory it allocated.</P><P><HR></P><H2><A NAME="Member Functions"></A>Member Functions</H2><P>&nbsp;</P><P><HR></P><H3><A NAME="AddInt64()"></A>AddInt64(),<A NAME="AddInt32()"></A>AddInt32(),<A NAME="AddInt16()"></A>AddInt16(),<A NAME="AddInt8()"></A>AddInt8(),<A NAME="AddUint64()"></A>AddUint64(),<A NAME="AddUint32()"></A>AddUint32(),<A NAME="AddUint16()"></A>AddUint16(),<A NAME="AddUint8()"></A>AddUint8(),<A NAME="AddNumber()"></A>AddNumber(),<A NAME="AddData()"></A> AddData()</H3><PRE>&nbsp;      void AddInt64(int64 data)      void AddInt32(int32 data)      void AddInt16(int16 data)      void AddInt8(int8 data)      void AddUint64(uint64 data)      void AddUint32(uint32 data)      void AddUint16(uint16 data)      void AddUint8(uint8 data)      void AddNumber(void* data, uint8 size)      void AddData(const void* data, uint32 length)</PRE><P>&nbsp;</P><P>Writes a number or data to the end of the buffer. For all callsexcept AddData, if the constructor specified use_network_order to betrue, then it is written to the buffer in network byte order,otherwise, it is written in the native order for the machine. Notethat it is safe to call AddData with a NULL pointer if the length iszero.</P><P><HR></P><H3><A NAME="Data()"></A>Data(),<A NAME="Size()"></A> Size()</H3><PRE>&nbsp;      uint8* Data() const      uint32 Size() const&nbsp;</PRE><P>Return a pointer to the beginning of the data buffer, and the sizeof the data in the buffer. Typically, after calling AddXXX and/orReplaceXXX to build the buffer for transmission, generating achecksum, and adding the checksum to the end of the message, one willcall Data and Size to get the fully constructed buffer and its size,and write the buffer to a socket.</P><P><HR></P><H3><A NAME="ExpandBufferForAdd()"></A>ExpandBufferForAdd(),<A NAME="ExternalAddDataAddress()"></A>ExternalAddDataAddress(),<A NAME="ExternalAddDataCompleted()"></A>ExternalAddDataCompleted()</H3><PRE>&nbsp;      void ExpandBufferForAdd(uint32 length)      int8* ExternalAddDataAddress() const      void ExternalAddDataCompleted(uint32 length)</PRE><P>&nbsp;</P><P>ExpandBufferForAdd makes room in the buffer for an add to occurfrom an external source (typically, reading from a socket). Once thisis done, you should call ExternalAddDataAddress to get the positionto which that data should be read, and, in the socket case, read datato that address. Once that is done, call ExternalAddDataCompleted totell the ChecksumDataBuffer how many bytes were added to it.</P><P><HR></P><H3><A NAME="Flush()"></A>Flush()</H3><PRE>&nbsp;      void Flush()&nbsp;</PRE><P>Flushes the buffer so that the read and write pointers are at thebeginning of the buffer. Typically, when writing to a socket, onewill build the buffer using AddXXX and ReplaceXXX calls, generatie achecksum, add the checksum to the end of the message, then send thefull buffer through a socket. At that point, to prepare for using theChecksumDataBuffer for the next message, one will call Flush. On thereceiving end, one will typically receive the message, extract itsdata using ReadXXX, and when finished, prepare for using theChecksumDataBuffer for the next message by calling Flush.</P><P><HR></P><H3><A NAME="GetChecksum16()"></A>GetChecksum16(),<A NAME="GetChecksum32()"></A>GetChecksum32(),<A NAME="GetWrappingChecksum()"></A>GetWrappingChecksum(),<A NAME="AddMoreWrappingChecksum()"></A>AddMoreWrappingChecksum()</H3><PRE>&nbsp;      uint16 GetChecksum16() const {return GetChecksum16(m_data,m_buffer_pos);}      uint32 GetChecksum32() const {return GetChecksum32(m_data,m_buffer_pos);}      uint32 GetWrappingChecksum() const {return GetWrappingChecksum(m_data,m_buffer_pos);}      static uint16 GetChecksum16(uint8* data, uint32 length);      static uint32 GetChecksum32(uint8* data, uint32 length);      static uint32 GetWrappingChecksum(uint8* data, uint32 length);      static uint32 AddMoreWrappingChecksum(uint8* data, uint32 length, uint32 prev_data_length,            uint32 prev_checksum)&nbsp;&nbsp;</PRE><P>The non-static versions of GetChecksum generate checksums for thefull buffer currently held by the ChecksumDataBuffer. The staticversions take a pointer to a buffer and a length. TheAddMoreWrappingChecksum method is used to continue generating awrapping checksum for a large message that is too big to fit in onebuffer. By calling it repeatedly, you can generate a wrappingchecksum on a discontiguous buffer. GetChecksum16 and GetChecksum32simply add all the bytes in a buffer in a uint16 or uint32, allowingit to wrap as the sum grows. The wrapping version generates achecksum in a uint32, and at each byte, shifts it one more bit to theright until it reaches a shift of 24, after which it shifts back tothe left again. See ChecksumDataBuffer.cpp for the implementation. Analmost bulletproof checksum is a combination of GetChecksum16 andGetWrappingChecksum.</P><P><HR></P><H3><A NAME="ReadInt64()"></A>ReadInt64(),<A NAME="ReadInt32()"></A>ReadInt32(),<B><A NAME="ReadInt16()"></A></B>ReadInt16(),<A NAME="ReadInt8()"></A>ReadInt8(),<A NAME="ReadUint64()"></A>ReadUint64(),<A NAME="ReadUint32()"></A>ReadUint32(),<A NAME="ReadUint16()"></A>ReadUint16(),<A NAME="ReadUint8()"></A>ReadUint8(),<A NAME="ReadNumber()"></A>ReadNumber(),<A NAME="ReadData()"></A>ReadData(),<A NAME="ReadInt64At()"></A>ReadInt64At(),<A NAME="ReadInt32At()"></A> ReadInt32At(),<B><A NAME="ReadInt16At()"></A></B>ReadInt16At(),<A NAME="ReadInt8At()"></A>ReadInt8At(),<A NAME="ReadUint64At()"></A>ReadUint64At(),<A NAME="ReadUint32At()"></A>ReadUint32At(),<A NAME="ReadUint16At()"></A>ReadUint16At(),<A NAME="ReadUint8At()"></A>ReadUint8At(),<A NAME="ReadNumberAt()"></A>ReadNumberAt(),<A NAME="ReadDataAt()"></A> ReadDataAt()</H3><PRE>&nbsp;      int64 ReadInt64()      int32 ReadInt32()      int16 ReadInt16()      int8  ReadInt8()      uint64 ReadUint64()      uint32 ReadUint32()      uint16 ReadUint16()      uint8  ReadUint8()      int64 ReadInt64At(uint32 at_pos) const      int32 ReadInt32At(uint32 at_pos) const      int16 ReadInt16At(uint32 at_pos) const      int8  ReadInt8At(uint32 at_pos) const      uint64 ReadUint64At(uint32 at_pos) const      uint32 ReadUint32At(uint32 at_pos) const      uint16 ReadUint16At(uint32 at_pos) const      uint8  ReadUint8At(uint32 at_pos) const      void ReadNumber(void* data, uint8 size)      void ReadNumberAt(void* data, uint8 size, uint32 at_pos)  const      const uint8* ReadData(uint32 length)      const uint8* ReadDataAt(uint32 length, uint32 at_pos)&nbsp;</PRE><P>Reads numbers or data from the buffer. For the At versions of theabove functions, the data is read from the specified position withoutaffecting the read pointer. Otherwise, the number of data is read atthe current read pointer, and the read pointer is advanced. For allcalls except ReadData, if the constructor specified use_network_orderto be true, then it is read from the buffer in network byte order,otherwise, it is read in the native order for the machine.</P><P><HR></P><H3><A NAME="ReplaceInt64()"></A>ReplaceInt64(),<A NAME="ReplaceInt32()"></A>ReplaceInt32(),<A NAME="ReplaceInt16()"></A>ReplaceInt16(),<A NAME="ReplaceInt8()"></A>ReplaceInt8(),<A NAME="ReplaceUint64()"></A>ReplaceUint64(),<A NAME="ReplaceUint32()"></A>ReplaceUint32(),<A NAME="ReplaceUint16()"></A>ReplaceUint16(),<A NAME="ReplaceUint8()"></A>ReplaceUint8(),<A NAME="ReplaceNumber()"></A>ReplaceNumber(),<A NAME="ReplaceData()"></A> ReplaceData()</H3><PRE>&nbsp;      void ReplaceInt64(int64 data, int32 at_pos)      void ReplaceInt32(int32 data, int32 at_pos)      void ReplaceInt16(int16 data, int32 at_pos)      void ReplaceInt8(int8 data, int32 at_pos)      void ReplaceUint64(uint64 data, int32 at_pos)      void ReplaceUint32(uint32 data, int32 at_pos)      void ReplaceUint16(uint16 data, int32 at_pos)      void ReplaceUint8(uint8 data, int32 at_pos)      void ReplaceNumber(void* data, uint8 size, uint32 at_pos)      void ReplaceData(const void* data, uint32 length, uint32 at_pos)&nbsp;</PRE><P>Replaces a number in the buffer. For all calls except ReplaceData,if the constructor specified use_network_order to be true, then it iswritten to the buffer in network byte order, otherwise, it is writtenin the native order for the machine. Note that it is safe to callReplaceData with a NULL pointer if the length is zero.</P><P><HR></P><P>By Brian Tietz</P><P>Copyright 2000</P><P>Bug reports (including documentation errors) and feature requestscan be sent to<A HREF="mailto:briant@timelinevista.com">briant@timelinevista.com</A>.</P><P>&nbsp;</P><P>&nbsp;</P></BODY></HTML>